#include ("stdlib.hhf")
#include ("macros/macros.hhf")
#include ("hide/hidelib.hhf")
#include ("w32/win32.hhf")

#include ("hide/dbgwin.hhf")
#include ("src/araynamacros.hhf")
#include ("src/genLexer.hhf")


const

	// this file generated by ResEd
	#include ("res/rsrc.hhf")
	


	max_objects	:= $FF_FFFF;

	saveEBX		:text := "(type savegame_t[ebx])";
	
	bufesi		:text := "(type tBuffer[esi])";
	
	roomebx			:text := "(type arayna_roomClass[ebx])";
	roomecx			:text := "(type arayna_roomClass[ecx])";
	roomesi			:text := "(type arayna_roomClass[esi])";
	roomeax			:text := "(type arayna_roomClass[EAX])";
	roomedx			:text := "(type arayna_roomClass[EDX])";
	
	areaebx			:text := "(type arayna_areaClass[ebx])";
	areaeax			:text := "(type arayna_areaClass[EAX])";
	areaecx			:text := "(type arayna_areaClass[ecx])";
		
	attrebx			:text := "(type attr_t[ebx])";
	attredx			:text := "(type attr_t[edx])";
	attrecx			:text := "(type attr_t[ecx])";
	attreax			:text := "(type attr_t[EAX])";
	attredi			:text := "(type attr_t[EDI])";
	attresi			:text := "(type attr_t[ESI])";

	pcesi			:text := "(type arayna_playerClass[esi])";
	pcebx			:text := "(type arayna_playerClass[ebx])";
	pceax			:text := "(type arayna_playerClass[EAX])";
	pcecx			:text := "(type arayna_playerClass[ECX])";
	
	containerebx	:text := "(type arayna_containerClass[ebx])";	

	listesi	:text	:= "(type arayna_listClass[esi])";
	listeax	:text	:= "(type arayna_listClass[eax])";
	listebx	:text	:= "(type arayna_listClass[ebx])";		

	// game modes
	mode_error	:= 0;
	mode_normal	:= 1;
	mode_dialog	:= 2;
	mode_command:= 3;
	mode_usewith:= 4;

	
type
	// Message and dispatch table related definitions:
		  
	MsgProc_t:	procedure( hwnd:dword; wParam:dword; lParam:dword );
	
	MsgProcPtr_t:
		record
			MessageValue	:dword;
			MessageHndlr	:MsgProc_t;			
		endrecord;


	arect:
		record
			x			:uns32;
			y			:uns32;
			width		:uns32;
			height	:uns32;
		endrecord;
	
	arayna_ini:
		record inherits( arect );
			bkgcol	:dword;
			txtcol	:dword;
			inv		:arect;
		endrecord;

	savegame_t:
		record
			// record starts after 2 string lines
			// that identify this as arayna save and
			// which module it belongs to
			
			// game_t fields
			curareaID	:uns32;
			curroomID	:uns32;
			fromroomID	:uns32;
			fromareaID	:uns32;
			lastaction	:uns32;
			moves		:uns32;
			
			
			// -arayna_playerClass inventory follows
			
		endrecord;

	game_t:
		record
			araynaObj	:pointer to arayna_objectClass;		// for main .id and .lbl
			curroom		:pointer to arayna_roomClass;
			fromroom		:uns32;				// keeps track of previous room 
			lastaction	:uns32;				// keeps track of the last action on an object
			lastobject	:pointer to arayna_objectClass;	// keeps track of the last object on which the player used an action
			thisobject	:pointer to arayna_objectClass;	// keeps track of which object is currently running an event (could be different from lastobject)
			pc				:pointer to arayna_playerClass;	// the player character
			pcname		:string;
			moves			:uns32;			// keeps track of # of moves made
			null_room	:pointer to arayna_roomClass;
			view			:dword;		// determines which list is current active one
			added			:dword;
			removed		:dword;
			intMove		:boolean;
			intEvent		:boolean;
			verbEvent	:boolean;
			saveEvent	:boolean;
			loadEvent	:boolean;
			status		:byte;		// 0 = no go, > 0 = state mode
			align(4);
		endrecord;

	attr_t:
		record
			tc			:uns32;		// type class: const_tc, var_tc, section_tc ...
			
			union
				atype		:uns32;	// determines which field in following union is valid
				line		:dword;	// section_tc only has one type, so this field is reused for section line
			endunion;
			
			union
				id			:dword;
				u			:uns32;
				s			:string;
				real		:real32;
				cursor	:dword;	// for sections
				dim0		:uns32;	// 1st dimension field for type_array
				buffer	:pointer to tBuffer;	// for type_fileio
			endunion;
			
			
			union
				// for section_tc
				filenode	:pointer to arayna_fileNode;
				
				// for object methods
				function: dword;
				
				// second dimension field for type_array
				dim1		:uns32;
				
			endunion;
			
			// will need more fields to determine section arguments, number of arguments, etc.
			align(4);
		endrecord;
		
	save_t:
		record
			cursor	:dword;
			line	:uns32;
		endrecord;

	
	pChar:	pointer to char;
	objectPtr   	:pointer to arayna_objectClass;
	roomPtr			:pointer to arayna_roomClass;
	pcPtr			:pointer to arayna_playerClass;


const

	// object states
	is_closed		:= @{0};			// object is closed but unlocked
	is_locked		:= @{1};			// is_closed = true.  object is locked and closed
	is_broken		:= @{2};			// object is broken and can't be used
	is_on				:= @{3};			// object is active
	is_special		:= @{4};			// quest item - doesn't decay when dropped
	is_shop			:= @{5};			// if room is a shop
		
	rtti_object		:= @{0};
	rtti_item		:= @{1};
	rtti_command	:= @{2};
	rtti_free01		:= @{3};			// depricated, this is free spot
	rtti_container	:= @{4};
	rtti_free02		:= @{5};			// depricated, this is free spot
	rtti_room		:= @{6};
	rtti_agent		:= @{7};
	rtti_topic		:= @{8};
	rtti_player		:= @{9};
	rtti_consumable	:= @{10};
	rtti_free03		:= @{11};		// depricated, this is free spot
	rtti_stackable	:= @{12};
	rtti_area		:= @{13};
		
	#includeonce ("src/araynaclasses.hhf")
	
const
	// some messages internal to the game
	ARAYNA_BASE		:= w.WM_USER+2000;
	ARAYNA_CLS		:= ARAYNA_BASE +1;	// 0, 0
	ARAYNA_RESET	:= ARAYNA_CLS +1;	// 0, 0


#include ("src/externals.hhf")

